인덱스
=
- 인덱스는 데이터를 빠르게 찾을 수 있는 하나의 수단입니다.
- B-트리
  - 인덱스는 보통 B-트리라는 자료 구조로 이루어져 있습니다.
  - 이는 루트 노드, 리프 노드와 루트 노드와 리프 노드를 잇는 브랜치 노드로 나뉩니다.
  - 찾고자 하는 원소를 전체 테이블을 탐색한다 하면 시간이 굉장히 오래 걸립니다. 하지만 찾고자 하는 원소가 있는 리프 노드로 들어가면 쉽게 찾을 수 있습니다.
  - 맨 위 루트 노드부터 탐색이 일어나며 브랜치 노드를 거쳐 리프 노드까지 내려옵니다.
  - 값이 크거나 같을 때까지 아래 노드로 내려와 정렬된 값을 기반으로 탐색합니다.
  - 이렇게 탐색 된 리프 노드에 도달해 데이터 포인터를 통해 결과 값을 반환하게 됩니다.
- 인덱스가 효율적인 이유와 대수확장성
  - 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문입니다.
  - 대수 확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미합니다.
  - 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가하게 됩니다.
- 인덱스 최적화 기법
  - 인덱스 최적화 기법은 데이터베이스마다 다르지만 기본적인 골조는 똑같습니다.
  - 인덱스는 비용이다.
    - 인덱스는 두 번 탐색하도록 강요합니다. 인덱스 리스트, 그 다음 컬렉션 순으로 탐색하기 때문이며, 관련 읽기 비용이 들기 때문입니다.
    - 컬렉션이 수정되었을 때 인덱스도 수정되어야 합니다. 이 때 B-트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 됩니다.
    - 그렇다고 무작정 인덱스를 설정하는 것이 답은 아니다. 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적입니다.
  - 항상 테스트하라
    - 최적화 기법은 서비스의 특징에 따라 달라집니다.
    - 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문입니다.
    - 그렇기에 쿼리를 보낸 이후에 테스팅하며 걸리는 시간을 최소화해야 합니다.
  - 복합 인덱스는 같은, 정렬, 다중 값, 가디널리티 순
    - 보통 여러 필드를 기반으로 조회를 할 대 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고 생성 순서에 따라 인덱스 성능이 달라집니다.
    - 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야 합니다.